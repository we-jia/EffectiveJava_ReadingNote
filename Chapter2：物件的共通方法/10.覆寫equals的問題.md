### 覆寫equals的問題

覆寫`equals(..)`通常會發生在，比較物件時會希望真正地比較它們邏輯上是否相等，而不是單純地比較它們的reference。那在覆寫時就有幾個準則必須得遵守，這幾個準則看起來其實跟數學上的相等比較極度相似：

1. 自反性：自己跟自己永遠都相等（`x.equals(x)`）。很難想像會違反這條規則，如果真的有違反，那麼使用`contains(..)`時就會回傳令人意外的結果。
2. 對稱性：`x.equals(y) == y.equals(x)`。看看下面程式碼的例子，這是單純比較大小寫的程式碼：

``` Java
public final class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }
    // Broken - violates symmetry!
    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString)
        return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
        if (o instanceof String) // One-way interoperability!
        return s.equalsIgnoreCase((String) o);
        return false;
    }
}

CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
String s = "polish";
System.out.println(cis.equals(s)); // true
System.out.println(s.equals(cis)); // false
```

如果要修改的話，可以將其`equals(..)`改成如下：

``` Java
@Override
public boolean equals(Object o) {
    return o instanceof CaseInsensitiveString &&
        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
}
```

1. 傳遞性：當第一個物件與第二個物件相等、第二個物件與第三個物件相等，那麼第一個物件就得要跟第三個物件相等。作者在書中有舉一個很有趣的例子，也跟里氏替換原則有關，這情況會發生在有繼承的情形：

``` Java
class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Point)) return false;
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }
}

class ColorPoint extends Point {
    private final Color color;
    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    // Broken - violates symmetry!
    @Override
        public boolean equals(Object o) {
        if (!(o instanceof ColorPoint))
            return false;
        return super.equals(o) && ((ColorPoint) o).color == color;
    }
}
```

這樣的建構方式，會讓兩個物件比較的位置相反時被打破，畢竟`Point`並不是`ColorPoint`的`instance`，那麼有人可能會想改成以下情況：

``` Java
@Override
public boolean equals(Object o) {
    if (!(o instanceof Point))
        return false;

    // If o is a normal Point, do a color-blind comparison
    if (!(o instanceof ColorPoint))
        return o.equals(this);

    // o is a ColorPoint; do a full comparison
    return super.equals(o) && ((ColorPoint) o).color == color;
}
```

這樣的話使用下面的物件，會讓傳遞性失效，`p1`、`p3`並不相等，但他們都與`p2`相等：

``` Java
ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
```

作者接著在繼承上還有提供一個不怎麼令人滿意的方法，這邊就不再提，如果要完成這樣的目的，作者傾向使用複合而不是繼承，這樣可以完美解決前面提到的問題：

``` Java
public class ColorPoint {
    private final Point point;
    private final Color color;
    public ColorPoint(int x, int y, Color color) {
        point = new Point(x, y);
        this.color = Objects.requireNonNull(color);
    }
    /**
    * Returns the point-view of this color point.
    */
    public Point asPoint() {
        return point;
    }
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof ColorPoint))
        return false;
        ColorPoint cp = (ColorPoint) o;
        return cp.point.equals(point) && cp.color.equals(color);
    }
}
```
